{"version":3,"file":"index.js","mappings":"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","sources":["webpack://ontyme/./src/Delay.ts","webpack://ontyme/./src/Limiter.ts","webpack://ontyme/webpack/bootstrap","webpack://ontyme/./src/index.ts"],"sourcesContent":["type callFunc<T> = (...args: any) => T;\r\ntype ReuseCall<T> = [Promise<any>, (func: callFunc<T>, milsDelay: number) => ReuseCall<T>, number?];\r\n\r\nexport class Delay {\r\n    // Holds all of the timeouts currently happening\r\n    private static timeouts: Map<number, number> = new Map();\r\n    // Holds all of the functions to be called when the timeout end or the page blurs\r\n    private static functions: Map<number, (...args: any) => any> = new Map();\r\n    // Holds all of the override listeners for promises, so they know when to delay resolve\r\n    private static overrideListeners: Map<number, (func: callFunc<any>, milsDelay: number) => any> = new Map();\r\n\r\n    /**\r\n     * A bulkified debouncer for calls\r\n     * All operations are aggregated for when you need \r\n     * \r\n     * @param func the function to call after the timeout\r\n     * @param milsDelay the delay for the timeout\r\n     * @param registerId a unique identifier for the caller, will be automatically created when not provided, reuse the identifier for resetting the delay\r\n     * @returns An object holding the promise created, a re-usable function for the same operation and the id created for the operation\r\n     */\r\n    public static callOnceReleased<T>(func: callFunc<T>, milsDelay: number, registerId?: number): {delay: (func: callFunc<T>, milsDelay: number) => ReuseCall<T>, id?: number} {\r\n        let id = registerId;\r\n        // If the id exists, override the current function call and delay\r\n        if (id && this.overrideListeners.has(id)) this.override(func, milsDelay, id);\r\n        else if (id == null) id = this.createRandomIdentifier(); // If the id does not exist, create it\r\n        // ^ if the use entered a custom id that is the one that will be used\r\n        // If the override listener does not exist (first call) create it\r\n        if(!this.functions.has(id)) {\r\n            this.onOverride((overrideFunc, overrideMilsDelay) => {\r\n                // Set the function to the new function\r\n                this.functions.set(id, overrideFunc);\r\n                // Clear the timeout and create a new one\r\n                window.clearTimeout(this.timeouts.get(id));\r\n                this.timeouts.set(id, this.createTimeout(overrideFunc, overrideMilsDelay, id));\r\n            }, id);\r\n            // Register the new function, for when we want to unload / blur the page\r\n            this.functions.set(id, func);\r\n            // Set the new timeout\r\n            this.timeouts.set(id, this.createTimeout(func, milsDelay, id));\r\n        }\r\n        // Return the same delay function and the id\r\n        return {\r\n            delay: ((overrideFunc: callFunc<T>, overrideMilsDelay: number) => this.callOnceReleased(overrideFunc, overrideMilsDelay, id)).bind(id),\r\n            id\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Remove the operation, and cancel it if you wish\r\n     * @param id The id of the operation to cancel\r\n     * @param clearTimeout Should clear timeout\r\n     */\r\n    public static purge(id: number, clearTimeout: boolean = true) {\r\n        // Remove all of the nodes for this request\r\n        if (clearTimeout) {\r\n            window.clearTimeout(this.timeouts.get(id));\r\n        }\r\n        this.timeouts.delete(id);\r\n        this.overrideListeners.delete(id);\r\n        this.functions.delete(id);\r\n    }\r\n\r\n    /**\r\n     * Use to register an event that will fire all callbacks when the page blurs / unloads\r\n     */\r\n    public static registerCallStackOnPageBlur(): void {\r\n        this.unloadCallsEvent(false);\r\n    }\r\n\r\n    /**\r\n     * Remove the events that will trigger when the page unloads / blurs\r\n     */\r\n    public static removeCallStackOnPageExit() {\r\n        this.unloadCallsEvent(true);\r\n    }\r\n\r\n    /**\r\n     * Overrides an existing operation's callback function and delay, and notifies subscribers\r\n     * @param func A new callback function for th opeartion\r\n     * @param milsDelay A new delay for the operation\r\n     * @param id A unique identifier for th operation\r\n     */\r\n    private static override<T>(func: callFunc<T>, milsDelay: number, id: number) {\r\n        const overrideListener = this.overrideListeners.get(id);\r\n        overrideListener(func, milsDelay);\r\n    }\r\n\r\n    /**\r\n     * A subscriber-like function that is used when the user overrides the current operation with a new callback and delay\r\n     * @param call A callback function accepting the new func and new delay given by the user\r\n     * @param id A unique identifier for this operation\r\n     */\r\n    private static onOverride<T>(call: (func: callFunc<T>, milsDelay: number) => void, id: number) {\r\n        this.overrideListeners.set(id, call);\r\n    }\r\n\r\n    /**\r\n     * Creates a timeout for the callback function, returns an id of the callback function\r\n     * \r\n     * @param func The callback function to call once the delay has ended\r\n     * @param milsDelay The time to wait in milliseconds\r\n     * @param id The unique identifier for this operation\r\n     * @returns The identifier of the createTimeout function\r\n     */\r\n    private static createTimeout<T>(func: callFunc<T>, milsDelay: number, id: number): number {\r\n        return window.setTimeout(() => {\r\n            try {\r\n                func();\r\n                this.purge(id);\r\n            } catch(e) {\r\n                console.error(e);\r\n                this.purge(id);\r\n                throw e;\r\n            }\r\n        }, milsDelay);\r\n    }\r\n\r\n    /**\r\n     * Create / Remove event listeners used when the page unloads / blurs\r\n     * @param remove boolean indicating whether or not this functions removes or adds the event listeners\r\n     * @returns \r\n     */\r\n    private static unloadCallsEvent(remove: boolean = false) {\r\n        if (remove) {\r\n            window.removeEventListener('beforeunload', () => this.unloadProcedure());\r\n            window.removeEventListener('blur', () => this.unloadProcedure());\r\n            return;\r\n        }\r\n        // NOTE: This will fire if you focus the developer console\r\n        window.addEventListener('beforeunload', () => this.unloadProcedure());\r\n        window.addEventListener('blur', () => this.unloadProcedure());\r\n    }\r\n\r\n    /**\r\n     * Creates a unique identifier for debounce calls\r\n     * @returns A \"unique\" identifier for the debounce calls\r\n     */\r\n    private static createRandomIdentifier(): number {\r\n        return Math.round(Math.random() * 10000); // Random number up to 10000, should be enough... should probably replace\r\n    }\r\n\r\n    /**\r\n     * Call all of the functions in the map\r\n     */\r\n    private static unloadProcedure(): void {\r\n        this.functions.forEach((func, id) => {\r\n            func();\r\n            this.purge(id, true);\r\n        });\r\n    }\r\n}\r\n","export class Limiter {\r\n  \r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export { Delay } from './Delay';\r\nexport { Limiter } from './Limiter';"],"names":[],"sourceRoot":""}