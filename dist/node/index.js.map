{"version":3,"file":"index.js","mappings":";;;;;;;;;;;;;AAGA;IAAA;IAmJA,CAAC;IA3IG;;;;;;;;OAQG;IACW,sBAAgB,GAA9B,UAAkC,IAAiB,EAAE,SAAiB,EAAE,UAAmB;QAA3F,iBAyBC;QAxBG,IAAI,EAAE,GAAG,UAAU,CAAC;QACpB,iEAAiE;QACjE,IAAI,EAAE,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC;YAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;aACxE,IAAI,EAAE,IAAI,IAAI;YAAE,EAAE,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,sCAAsC;QAC/F,qEAAqE;QACrE,iEAAiE;QACjE,IAAG,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YACxB,IAAI,CAAC,UAAU,CAAC,UAAC,YAAY,EAAE,iBAAiB;gBAC5C,uCAAuC;gBACvC,KAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;gBACrC,yCAAyC;gBACzC,MAAM,CAAC,YAAY,CAAC,KAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC3C,KAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,EAAE,KAAI,CAAC,aAAa,CAAC,YAAY,EAAE,iBAAiB,EAAE,EAAE,CAAC,CAAC,CAAC;YACnF,CAAC,EAAE,EAAE,CAAC,CAAC;YACP,wEAAwE;YACxE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;YAC7B,sBAAsB;YACtB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC;SAClE;QACD,4CAA4C;QAC5C,OAAO;YACH,KAAK,EAAE,CAAC,UAAC,YAAyB,EAAE,iBAAyB,IAAK,YAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE,iBAAiB,EAAE,EAAE,CAAC,EAA1D,CAA0D,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;YACtI,EAAE;SACL,CAAC;IACN,CAAC;IAED;;;;OAIG;IACW,WAAK,GAAnB,UAAoB,EAAU,EAAE,YAA4B;QAA5B,kDAA4B;QACxD,2CAA2C;QAC3C,IAAI,YAAY,EAAE;YACd,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;SAC9C;QACD,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QACzB,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IAC9B,CAAC;IAED;;OAEG;IACW,iCAA2B,GAAzC;QACI,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;IACjC,CAAC;IAED;;OAEG;IACW,+BAAyB,GAAvC;QACI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAED;;;;;OAKG;IACY,cAAQ,GAAvB,UAA2B,IAAiB,EAAE,SAAiB,EAAE,EAAU;QACvE,IAAM,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACxD,gBAAgB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACtC,CAAC;IAED;;;;OAIG;IACY,gBAAU,GAAzB,UAA6B,IAAoD,EAAE,EAAU;QACzF,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;IACzC,CAAC;IAED;;;;;;;OAOG;IACY,mBAAa,GAA5B,UAAgC,IAAiB,EAAE,SAAiB,EAAE,EAAU;QAAhF,iBAWC;QAVG,OAAO,MAAM,CAAC,UAAU,CAAC;YACrB,IAAI;gBACA,IAAI,EAAE,CAAC;gBACP,KAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAClB;YAAC,OAAM,CAAC,EAAE;gBACP,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACjB,KAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBACf,MAAM,CAAC,CAAC;aACX;QACL,CAAC,EAAE,SAAS,CAAC,CAAC;IAClB,CAAC;IAED;;;;OAIG;IACY,sBAAgB,GAA/B,UAAgC,MAAuB;QAAvD,iBASC;QAT+B,uCAAuB;QACnD,IAAI,MAAM,EAAE;YACR,MAAM,CAAC,mBAAmB,CAAC,cAAc,EAAE,cAAM,YAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,CAAC,CAAC;YACzE,MAAM,CAAC,mBAAmB,CAAC,MAAM,EAAE,cAAM,YAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,CAAC,CAAC;YACjE,OAAO;SACV;QACD,0DAA0D;QAC1D,MAAM,CAAC,gBAAgB,CAAC,cAAc,EAAE,cAAM,YAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,CAAC,CAAC;QACtE,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,cAAM,YAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,CAAC,CAAC;IAClE,CAAC;IAED;;;OAGG;IACY,4BAAsB,GAArC;QACI,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,yEAAyE;IACvH,CAAC;IAED;;OAEG;IACY,qBAAe,GAA9B;QAAA,iBAKC;QAJG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,EAAE;YAC5B,IAAI,EAAE,CAAC;YACP,KAAI,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACP,CAAC;IAjJD,gDAAgD;IACjC,cAAQ,GAAwB,IAAI,GAAG,EAAE,CAAC;IACzD,iFAAiF;IAClE,eAAS,GAAuC,IAAI,GAAG,EAAE,CAAC;IACzE,uFAAuF;IACxE,uBAAiB,GAAiE,IAAI,GAAG,EAAE,CAAC;IA6I/G,YAAC;CAAA;AAnJY,sBAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHlB;IAAkD,wCAAK;IACrD,8BAAY,OAAe;QAA3B,YACE,kBAAM,OAAO,CAAC,SAEf;QADC,KAAI,CAAC,IAAI,GAAG,sBAAsB,CAAC;;IACrC,CAAC;IACH,2BAAC;AAAD,CAAC,CALiD,KAAK,GAKtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLD;IAAqD,2CAAK;IAA1D;;IAA4D,CAAC;IAAD,8BAAC;AAAD,CAAC,CAAR,KAAK,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACA7D,wIAAwE;AACxE,oEAA6B;AAG7B;;GAEG;AACH;IAyBE;;;;OAIG;IACH,wBAAsB,KAAqD,EAAU,KAAe;QAAf,UAAK,GAAL,KAAK,CAAU;QA5BpG;;WAEG;QACK,cAAS,GAAmD,eAAK,CAAC,MAAM,EAAE,CAAC;QA0BjF,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAzBD;;;;OAIG;IACW,uBAAQ,GAAtB,UAA+B,KAAwC;QAAxC,kCAAwC;QACrE,OAAO,IAAI,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAC1C,CAAC;IAED;;;;OAIG;IACW,wBAAS,GAAvB,UAAgC,QAAoD;QAApD,wCAAoD;QAClF,OAAO,IAAI,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC5C,CAAC;IAWD;;;OAGG;IACI,6BAAI,GAAX;QACE,IAAI,IAAI,CAAC,KAAK;YAAE,MAAM,IAAI,iCAAuB,CAAC,oEAAoE,CAAC,CAAC;QACxH,IAAI,IAAI,CAAC,OAAO,EAAE;YAAE,OAAO;QAC3B,OAAQ,IAAI,CAAC,SAAS,CAAC,OAAO,EAA4B,EAAE,CAAC;IAC/D,CAAC;IAED;;OAEG;IACK,gCAAO,GAAf;;;;yBACS,CAAC,IAAI,CAAC,OAAO,EAAE;oBACpB,qBAAO,IAAI,CAAC,SAAS,CAAC,OAAO,EAA4B,EAAE;;oBAA3D,SAA2D,CAAC;;;;;KAE/D;IAED;;;OAGG;IACU,kCAAS,GAAtB;;;gBACE,IAAI,CAAC,IAAI,CAAC,KAAK;oBAAE,MAAM,IAAI,iCAAuB,CAAC,8DAA8D,CAAC,CAAC;gBACnH,IAAI,IAAI,CAAC,OAAO,EAAE;oBAAE,sBAAO;gBAC3B,sBAAQ,IAAI,CAAC,SAAS,CAAC,OAAO,EAAqC,EAAE,EAAC;;;KACvE;IAED;;OAEG;IACW,qCAAY,GAA1B;;;;;6BACS,CAAC,IAAI,CAAC,OAAO,EAAE;qDACb,IAAI,CAAC,SAAS,CAAC,OAAO,EAAqC,EAAE;4BAApE,gCAAoE;;wBAApE,SAAoE,CAAC;;;;;;KAExE;IAED;;;OAGG;IACI,6BAAI,GAAX;QAAY,eAAgE;aAAhE,UAAgE,EAAhE,qBAAgE,EAAhE,IAAgE;YAAhE,0BAAgE;;QAC1E,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAED;;;OAGG;IACI,6BAAI,GAAX;QACE,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/B,CAAC;IAED;;;OAGG;IACI,gCAAO,GAAd;QACE,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;IAClC,CAAC;IACH,qBAAC;AAAD,CAAC;AA/FY,wCAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACP3B,oEAA6B;AAC7B,+HAAkE;AAGlE;;;;;;GAMG;AACH;IASE;;;;;OAKG;IACH,qBAAoB,UAAkB,EAAU,YAAoB;QAAhD,eAAU,GAAV,UAAU,CAAQ;QAAU,iBAAY,GAAZ,YAAY,CAAQ;QAd5D,eAAU,GAAkB,eAAK,CAAC,MAAM,EAAE,CAAC;QAC3C,iBAAY,GAAiC,eAAK,CAAC,MAAM,EAAE,CAAC;QAC5D,YAAO,GAAe,IAAI,KAAK,EAAE,CAAC;QAClC,aAAQ,GAAY,KAAK,CAAC;QAC1B,gBAAW,GAAY,KAAK,CAAC;QAE7B,aAAQ,GAAW,CAAC,CAAC;IAQ0C,CAAC;IAExE;;;;OAIG;IACU,0BAAI,GAAjB,UAAkB,KAAyB;;;;gBACzC,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBACrC,wEAAwE;gBACxE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC3B,sGAAsG;gBACtG,sBAAO,IAAI,OAAO,CAAC,iBAAO;wBACxB,KAAI,CAAC,WAAW,CAAC;4BACf,IAAI,KAAI,CAAC,UAAU,EAAE,EAAE,2CAA2C;gCAChE,KAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,KAAI,CAAC,QAAQ,CAAC;gCAC3C,OAAO,CAAC;oCACN,YAAY,EAAE,KAAI,CAAC,QAAQ;oCAC3B,OAAO,EAAE,KAAI,CAAC,OAAO;iCACtB,CAAC,CAAC;6BACJ;wBACH,CAAC,CAAC,CAAC;wBACH,kCAAkC;wBAClC,KAAI,CAAC,eAAe,EAAE,CAAC;oBACzB,CAAC,CAAC,EAAC;;;KAEJ;IAED;;;OAGG;IACI,0BAAI,GAAX;QAAY,eAA4B;aAA5B,UAA4B,EAA5B,qBAA4B,EAA5B,IAA4B;YAA5B,0BAA4B;;QACtC,IAAI,IAAI,CAAC,UAAU;YAAE,MAAM,IAAI,8BAAoB,CAAC,gEAAgE,CAAC,CAAC;QACtH,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QACrC,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;IAC9C,CAAC;IAED;;;;OAIG;IACI,iCAAW,GAAlB,UAAmB,SAAkB;QACnC,mDAAmD;QACnD,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU;YAAE,OAAO,IAAI,CAAC;QAC1D,oHAAoH;QACpH,IAAM,IAAI,GAAG,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;QACzD,sGAAsG;QACtG,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,GAAG,IAAI,EAAE;YAClE,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;SAC3B;QACD,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;IAClD,CAAC;IAED;;OAEG;IACI,4BAAM,GAAb;QACE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW;YAAE,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC/E,CAAC;IAKD,sBAAW,mCAAU;QAHrB;;WAEG;aACH;YACE,OAAO,IAAI,CAAC,QAAQ,CAAC;QACvB,CAAC;;;OAAA;IAED;;;OAGG;IACK,iCAAW,GAAnB,UAAoB,IAAgB;QAClC,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;IAChC,CAAC;IAED;;OAEG;IACW,qCAAe,GAA7B;;;;;;;wBACE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,CAAC,iEAAiE;;;;wBAC/D,uBAAI,CAAC,SAAS,EAAE;;;;;wBAA1B,MAAM;wBACrB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;wBAE5B,mCAAmC;wBACnC,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;wBACzB,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,+BAA+B;;;;;KAC1D;IAED;;OAEG;IACY,+BAAS,GAAxB;;;;;;6BACQ,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;6BAG1B,IAAI,CAAC,WAAW,EAAE,EAAlB,wBAAkB;wBACpB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;qDAC9B,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC;4BAArC,gCAAqC;;wBAArC,SAAqC,CAAC;wBACtC,wBAAS;4BAIL,6BAAM,IAAI,OAAO,CAAC,iBAAO;4BAC7B,UAAU,CAAC;gCACT,KAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;gCACpC,IAAM,IAAI,GAAG,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;gCACzC,IAAM,GAAG,GAAG,IAAI,EAAE,CAAC;gCACnB,OAAO,CAAC,GAAG,CAAC,CAAC;4BACf,CAAC,EAAE,KAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;wBAC/B,CAAC,CAAC;wEAPI,SAOJ;;oBATF,yDAAyD;oBACzD,iEAAiE;oBACjE,gCAOE;;wBATF,yDAAyD;wBACzD,iEAAiE;wBACjE,SAOE,CAAC;;;;;;KAER;IAED;;;;OAIG;IACK,uCAAiB,GAAzB,UAA0B,SAAkB;QAC1C,4FAA4F;QAC5F,SAAS,GAAG,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,IAAI,CAAC,GAAG,EAAE,CAAC;QACpC,OAAO,IAAI,CAAC,YAAY,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;IAClE,CAAC;IACH,kBAAC;AAAD,CAAC;AA7IY,kCAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXxB;IAAsC,yBAAK;IAEzC;;;OAGG;IACH;QAAoB,eAAoB;aAApB,UAAoB,EAApB,qBAAoB,EAApB,IAAoB;YAApB,0BAAoB;;kCAC7B,KAAK;IAChB,CAAC;IAEM,YAAM,GAAb;QACE,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACxC,CAAC;IAEM,uBAAO,GAAd,UAAe,KAAQ;QACrB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACnB,CAAC;IAEM,2BAAW,GAAlB,UAAmB,MAAgB;QACjC,IAAI,CAAC,IAAI,OAAT,IAAI,EAAS,MAAM,EAAE;IACvB,CAAC;IAEM,uBAAO,GAAd;QACE,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;IACtB,CAAC;IAEM,oBAAI,GAAX;QACE,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC;IACjB,CAAC;IAEM,uBAAO,GAAd;QACE,OAAO,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;IAC3B,CAAC;IACH,YAAC;AAAD,CAAC,CAjCqC,KAAK,GAiC1C;;;;;;;;UCjCD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;;;;ACtBA,mEAAgC;AAAvB,oGAAK;AACd,qGAAoD;AAA3C,sHAAW;AACpB,8GAA0D;AAAjD,+HAAc","sources":["webpack://ontyme/./src/Delay.ts","webpack://ontyme/./src/Errors/LimiterFinishedError.ts","webpack://ontyme/./src/Errors/ManagedLimiterModeError.ts","webpack://ontyme/./src/Limiter/ManagedLimiter.ts","webpack://ontyme/./src/Limiter/TimeLimiter.ts","webpack://ontyme/./src/Queue.ts","webpack://ontyme/webpack/bootstrap","webpack://ontyme/./src/index.ts"],"sourcesContent":["type callFunc<T> = (...args: any) => T;\r\ntype ReuseCall<T> = [Promise<any>, (func: callFunc<T>, milsDelay: number) => ReuseCall<T>, number?];\r\n\r\nexport class Delay {\r\n    // Holds all of the timeouts currently happening\r\n    private static timeouts: Map<number, number> = new Map();\r\n    // Holds all of the functions to be called when the timeout end or the page blurs\r\n    private static functions: Map<number, (...args: any) => any> = new Map();\r\n    // Holds all of the override listeners for promises, so they know when to delay resolve\r\n    private static overrideListeners: Map<number, (func: callFunc<any>, milsDelay: number) => any> = new Map();\r\n\r\n    /**\r\n     * A bulkified debouncer for calls\r\n     * All operations are aggregated for when you need \r\n     * \r\n     * @param func the function to call after the timeout\r\n     * @param milsDelay the delay for the timeout\r\n     * @param registerId a unique identifier for the caller, will be automatically created when not provided, reuse the identifier for resetting the delay\r\n     * @returns An object holding the promise created, a re-usable function for the same operation and the id created for the operation\r\n     */\r\n    public static callOnceReleased<T>(func: callFunc<T>, milsDelay: number, registerId?: number): {delay: (func: callFunc<T>, milsDelay: number) => ReuseCall<T>, id?: number} {\r\n        let id = registerId;\r\n        // If the id exists, override the current function call and delay\r\n        if (id && this.overrideListeners.has(id)) this.override(func, milsDelay, id);\r\n        else if (id == null) id = this.createRandomIdentifier(); // If the id does not exist, create it\r\n        // ^ if the use entered a custom id that is the one that will be used\r\n        // If the override listener does not exist (first call) create it\r\n        if(!this.functions.has(id)) {\r\n            this.onOverride((overrideFunc, overrideMilsDelay) => {\r\n                // Set the function to the new function\r\n                this.functions.set(id, overrideFunc);\r\n                // Clear the timeout and create a new one\r\n                window.clearTimeout(this.timeouts.get(id));\r\n                this.timeouts.set(id, this.createTimeout(overrideFunc, overrideMilsDelay, id));\r\n            }, id);\r\n            // Register the new function, for when we want to unload / blur the page\r\n            this.functions.set(id, func);\r\n            // Set the new timeout\r\n            this.timeouts.set(id, this.createTimeout(func, milsDelay, id));\r\n        }\r\n        // Return the same delay function and the id\r\n        return {\r\n            delay: ((overrideFunc: callFunc<T>, overrideMilsDelay: number) => this.callOnceReleased(overrideFunc, overrideMilsDelay, id)).bind(id),\r\n            id\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Remove the operation, and cancel it if you wish\r\n     * @param id The id of the operation to cancel\r\n     * @param clearTimeout Should clear timeout\r\n     */\r\n    public static purge(id: number, clearTimeout: boolean = true) {\r\n        // Remove all of the nodes for this request\r\n        if (clearTimeout) {\r\n            window.clearTimeout(this.timeouts.get(id));\r\n        }\r\n        this.timeouts.delete(id);\r\n        this.overrideListeners.delete(id);\r\n        this.functions.delete(id);\r\n    }\r\n\r\n    /**\r\n     * Use to register an event that will fire all callbacks when the page blurs / unloads\r\n     */\r\n    public static registerCallStackOnPageBlur(): void {\r\n        this.unloadCallsEvent(false);\r\n    }\r\n\r\n    /**\r\n     * Remove the events that will trigger when the page unloads / blurs\r\n     */\r\n    public static removeCallStackOnPageExit() {\r\n        this.unloadCallsEvent(true);\r\n    }\r\n\r\n    /**\r\n     * Overrides an existing operation's callback function and delay, and notifies subscribers\r\n     * @param func A new callback function for th opeartion\r\n     * @param milsDelay A new delay for the operation\r\n     * @param id A unique identifier for th operation\r\n     */\r\n    private static override<T>(func: callFunc<T>, milsDelay: number, id: number) {\r\n        const overrideListener = this.overrideListeners.get(id);\r\n        overrideListener(func, milsDelay);\r\n    }\r\n\r\n    /**\r\n     * A subscriber-like function that is used when the user overrides the current operation with a new callback and delay\r\n     * @param call A callback function accepting the new func and new delay given by the user\r\n     * @param id A unique identifier for this operation\r\n     */\r\n    private static onOverride<T>(call: (func: callFunc<T>, milsDelay: number) => void, id: number) {\r\n        this.overrideListeners.set(id, call);\r\n    }\r\n\r\n    /**\r\n     * Creates a timeout for the callback function, returns an id of the callback function\r\n     * \r\n     * @param func The callback function to call once the delay has ended\r\n     * @param milsDelay The time to wait in milliseconds\r\n     * @param id The unique identifier for this operation\r\n     * @returns The identifier of the createTimeout function\r\n     */\r\n    private static createTimeout<T>(func: callFunc<T>, milsDelay: number, id: number): number {\r\n        return window.setTimeout(() => {\r\n            try {\r\n                func();\r\n                this.purge(id);\r\n            } catch(e) {\r\n                console.error(e);\r\n                this.purge(id);\r\n                throw e;\r\n            }\r\n        }, milsDelay);\r\n    }\r\n\r\n    /**\r\n     * Create / Remove event listeners used when the page unloads / blurs\r\n     * @param remove boolean indicating whether or not this functions removes or adds the event listeners\r\n     * @returns \r\n     */\r\n    private static unloadCallsEvent(remove: boolean = false) {\r\n        if (remove) {\r\n            window.removeEventListener('beforeunload', () => this.unloadProcedure());\r\n            window.removeEventListener('blur', () => this.unloadProcedure());\r\n            return;\r\n        }\r\n        // NOTE: This will fire if you focus the developer console\r\n        window.addEventListener('beforeunload', () => this.unloadProcedure());\r\n        window.addEventListener('blur', () => this.unloadProcedure());\r\n    }\r\n\r\n    /**\r\n     * Creates a unique identifier for debounce calls\r\n     * @returns A \"unique\" identifier for the debounce calls\r\n     */\r\n    private static createRandomIdentifier(): number {\r\n        return Math.round(Math.random() * 10000); // Random number up to 10000, should be enough... should probably replace\r\n    }\r\n\r\n    /**\r\n     * Call all of the functions in the map\r\n     */\r\n    private static unloadProcedure(): void {\r\n        this.functions.forEach((func, id) => {\r\n            func();\r\n            this.purge(id, true);\r\n        });\r\n    }\r\n}\r\n","export default class LimiterFinishedError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'LimiterFinishedError';\r\n  }\r\n}","export default class ManagedLimiterModeError extends Error {}","import ManagedLimiterModeError from \"../Errors/ManagedLimiterModeError\";\r\nimport Queue from \"../Queue\";\r\ntype QueueFunction<T> = (...args: any) => T\r\n\r\n/**\r\n * A call limiter controlled by the user of the class\r\n */\r\nexport class ManagedLimiter<FuncsT> {\r\n\r\n  /**\r\n   * Holds the queue of calls the user is preparing\r\n   */\r\n  private callQueue: Queue<QueueFunction<FuncsT | Promise<FuncsT>>> = Queue.create();\r\n\r\n  /**\r\n   * The entry point for the synchronous ManagedLimiter, all functions will be executed and their value will be returned\r\n   * @param funcs An array of functions\r\n   * @returns A ManagedLimiter\r\n   */\r\n  public static makeSync<FuncsT>(funcs: Array<QueueFunction<FuncsT>> = []): ManagedLimiter<FuncsT> {\r\n    return new ManagedLimiter(funcs, false);\r\n  }\r\n\r\n  /**\r\n   * The entry point for the asynchronous ManagedLimiter, all promises will be returned as a promise\r\n   * @param promises An array of promises to pre-populate the queue with\r\n   * @returns A ManagedLimiter\r\n   */\r\n  public static makeAsync<FuncsT>(promises: Array<QueueFunction<Promise<FuncsT>>> = []): ManagedLimiter<FuncsT> {\r\n    return new ManagedLimiter(promises, true);\r\n  }\r\n\r\n  /**\r\n   * Create a new instance of the class and return it to the user\r\n   * @param funcs What to pre-populate the queue with\r\n   * @param async Whether or not the class is asynchronous\r\n   */\r\n  protected constructor(funcs: Array<QueueFunction<FuncsT | Promise<FuncsT>>>, private async?: boolean) {\r\n    this.callQueue.bulkEnqueue(funcs);\r\n  }\r\n\r\n  /**\r\n   * Calls the next function in the queue and returns its value\r\n   * @returns The value of the function from the queue, with the return type as indicated by the user\r\n   */\r\n  public next(): FuncsT {\r\n    if (this.async) throw new ManagedLimiterModeError('Cant call next on a asynchronous limiter, use asyncNext() instead.');\r\n    if (this.isEmpty()) return;\r\n    return (this.callQueue.dequeue() as QueueFunction<FuncsT>)();\r\n  }\r\n\r\n  /**\r\n   * Runs through the queue using a generator, for when you want to loop through the values\r\n   */\r\n  public *genNext(): Generator<FuncsT, any, any> {\r\n    while (!this.isEmpty()) {\r\n      yield (this.callQueue.dequeue() as QueueFunction<FuncsT>)();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calls the next function asynchronously\r\n   * @returns The promise given by the user\r\n   */\r\n  public async asyncNext(): Promise<FuncsT> {\r\n    if (!this.async) throw new ManagedLimiterModeError('Cant call next on a synchronous limiter, use next() instead.');\r\n    if (this.isEmpty()) return;\r\n    return (this.callQueue.dequeue() as QueueFunction<Promise<FuncsT>>)();\r\n  }\r\n\r\n  /**\r\n   * Runs through the promises using a generator, for when you want to loop through all of the promises\r\n   */\r\n  public async *genAsyncNext(): AsyncGenerator<FuncsT, any, any> {\r\n    while (!this.isEmpty()) {\r\n      yield (this.callQueue.dequeue() as QueueFunction<Promise<FuncsT>>)();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add additional promises or functions to the call queue\r\n   * @param funcs An array of functions or promises\r\n   */\r\n  public push(...funcs: Array<QueueFunction<FuncsT> | (() => Promise<FuncsT>)>): void {\r\n    this.callQueue.bulkEnqueue(funcs);\r\n  }\r\n\r\n  /**\r\n   * Returns the size of the queue at this point in time\r\n   * @returns size of the queue\r\n   */\r\n  public size(): number {\r\n    return this.callQueue.length;\r\n  }\r\n\r\n  /**\r\n   * Returns true for when the queue is empty or false for when there are additional functions / promises in the queue\r\n   * @returns is the queue empty\r\n   */\r\n  public isEmpty(): boolean {\r\n    return this.callQueue.isEmpty();\r\n  }\r\n}","import Queue from \"../Queue\";\r\nimport LimiterFinishedError from '../Errors/LimiterFinishedError';\r\ntype AnyFunction = (...args: any) => any;\r\n\r\n/**\r\n * This class will limit the number of calls you make by calculating the number of calls made in the time-frame provided\r\n * The point of this class is to make as many calls as possible, clearing the queue as fast as the user is allowed to\r\n * This is good when you have batches of calls you need to make and you do not want to spread them out\r\n * For example if you have an api that accepts 60 calls per minute and you have 60 calls to make, there is no need to wait 1 second between\r\n * each call, you can just exhaust your limits all at once\r\n */\r\nexport class TimeLimiter {\r\n  private timestamps: Queue<number> = Queue.create();\r\n  private requestQueue: Queue<(...args: any) => any> = Queue.create();\r\n  private results: Array<any> = new Array();\r\n  private finished: boolean = false;\r\n  private makingCalls: boolean = false;\r\n  private queueDoneCallback: () => void;\r\n  private timeTook: number = 0;\r\n\r\n  /**\r\n   * Setup a rate limiter for making function calls using a time-frame and the number\r\n   * of calls you can make in that time-frame\r\n   * @param numOfCalls Number of calls you can make in time-frame\r\n   * @param milsInterval The time-frame in milliseconds\r\n   */\r\n  constructor(private numOfCalls: number, private milsInterval: number) {}\r\n\r\n  /**\r\n   * Create a limiter call and return a promise, the promise will resolve when the queue is done\r\n   * @param funcs An array of functions to pass into the request queue\r\n   * @returns A promise resolving the results of the limiter\r\n   */\r\n  public async make(funcs: Array<AnyFunction>): Promise<any> {\r\n    this.requestQueue.bulkEnqueue(funcs);\r\n    // Make all of the calls until the queue is done (generator is finished)\r\n    this.timeTook = Date.now();\r\n    // Return a promise that will resolve when the Limiter is marked as finished and the queue is depleted\r\n    return new Promise(resolve => {\r\n      this.onQueueDone(() => { // Register a callback for when the queue is done\r\n        if (this.isFinished) { // Only resolve if the limiter is marked as\r\n          this.timeTook = Date.now() - this.timeTook;\r\n          resolve({\r\n            milliseconds: this.timeTook,\r\n            results: this.results\r\n          });\r\n        }\r\n      });\r\n      // Begin running through the queue\r\n      this.runThroughQueue();\r\n    });\r\n    // Resolve a promise all, this is good for when you have multiple calls that all depend on each other\r\n  }\r\n\r\n  /**\r\n   * Push a function or an array of functions into the call queue of the limiter\r\n   * @param funcs An array of functions or a single function\r\n   */\r\n  public push(...funcs: Array<AnyFunction>): void {\r\n    if (this.isFinished) throw new LimiterFinishedError(\"Cant push more functions to a limiter that is set to finished.\");\r\n    this.requestQueue.bulkEnqueue(funcs);\r\n    !this.makingCalls && this.runThroughQueue();\r\n  }\r\n\r\n  /**\r\n   * Returns wether or not you can make a call, if nothing is passed, Date.now() will be used to calculate (preferred)\r\n   * @param timestamp a timestamp for when you want to calculate ahead of time\r\n   * @returns whether or not you can make a call for the timestamp or the Date.now() value\r\n   */\r\n  public canMakeCall(timestamp?: number): boolean {\r\n    // Deals with permissions up to the number of calls\r\n    if (this.timestamps.length < this.numOfCalls) return true;\r\n    // If the timestamp or time now - the mils interval is greater than the first call in the queue, you can make a call\r\n    const time = timestamp ?? Date.now() - this.milsInterval;\r\n    // While the queue is not empty and the first timestamp in the queue is smaller than the time function\r\n    while (!this.timestamps.isEmpty() && this.timestamps.peek() < time) {\r\n      this.timestamps.dequeue();\r\n    }\r\n    return this.timestamps.length < this.numOfCalls;\r\n  }\r\n\r\n  /**\r\n   * Mark the Limiter as finished, when the queue is done the results will be resolved\r\n   */\r\n  public finish() {\r\n    this.finished = true;\r\n    if (this.requestQueue.isEmpty && !this.makingCalls) this.queueDoneCallback();\r\n  }\r\n\r\n  /**\r\n   * Whether or not the limiter is done accepting calls\r\n   */\r\n  public get isFinished(): boolean {\r\n    return this.finished;\r\n  }\r\n\r\n  /**\r\n   * Register a callback for when the is queue done\r\n   * @param call a callback function that fires when the queue is done\r\n   */\r\n  private onQueueDone(call: () => void) {\r\n    this.queueDoneCallback = call;\r\n  }\r\n\r\n  /**\r\n   * Call the makeCalls generator and mark the limiter's making calls parameter\r\n   */\r\n  private async runThroughQueue() {\r\n    this.makingCalls = true; // Before calling the generator, make the Limiter as making calls\r\n    for await (const result of this.makeCalls()) {\r\n      this.results.push(result);\r\n    }\r\n    // Reset the making calls parameter\r\n    this.makingCalls = false;\r\n    this.queueDoneCallback(); // Call the queue done callback\r\n  }\r\n\r\n  /** \r\n   * A generator for calling the functions given to the queue\r\n   */\r\n  private async *makeCalls(): any {\r\n    while(!this.requestQueue.isEmpty()) {\r\n      // If can make call outright\r\n      //if (this.requestQueue.length > 0) {\r\n        if (this.canMakeCall()) {\r\n          this.timestamps.enqueue(Date.now());\r\n          yield (this.requestQueue.dequeue()());\r\n          continue;\r\n        }\r\n        // If cant make call, start an interval until time clears\r\n        // This will not wait for functions that are promises them-selves\r\n        yield await new Promise(resolve => {\r\n          setTimeout(() => {\r\n            this.timestamps.enqueue(Date.now());\r\n            const func = this.requestQueue.dequeue();\r\n            const res = func();\r\n            resolve(res);\r\n          }, this.milsUntilNextCall());\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the number of milliseconds to wait until you can make another call from the request queue\r\n   * @param timestamp a timestamp to use for comparison, if not passed, Date.now() is used\r\n   * @returns the milliseconds until the next call can be made\r\n   */\r\n  private milsUntilNextCall(timestamp?: number): number {\r\n    // The interval - The difference between the timestamp / Date.now() and the oldest timestamp\r\n    timestamp = timestamp ?? Date.now();\r\n    return this.milsInterval - (timestamp - this.timestamps.peek());\r\n  }\r\n}\r\n","export default class Queue<T> extends Array {\r\n\r\n  /**\r\n   * Use Queue.create to create a new queue that is extending an Array\r\n   * @param items Initial array items\r\n   */\r\n  private constructor(...items: Array<any>) {\r\n    super(...items);\r\n  }\r\n\r\n  static create<T>(): Queue<T> {\r\n    return Object.create(Queue.prototype);\r\n  }\r\n  \r\n  public enqueue(value: T): void {\r\n    this.push(value);\r\n  }\r\n\r\n  public bulkEnqueue(values: Array<T>): void {\r\n    this.push(...values);\r\n  }\r\n\r\n  public dequeue(): T {\r\n    return this.shift();\r\n  }\r\n\r\n  public peek(): T {\r\n    return this[0];\r\n  }\r\n\r\n  public isEmpty(): boolean {\r\n    return this.length === 0;\r\n  }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export { Delay } from './Delay';\r\nexport { TimeLimiter } from './Limiter/TimeLimiter';\r\nexport { ManagedLimiter } from './Limiter/ManagedLimiter';"],"names":[],"sourceRoot":""}